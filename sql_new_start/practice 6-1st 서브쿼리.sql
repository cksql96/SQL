-- ------------------------------------------------------
-- 1. Sub-query (부속질의)
-- ------------------------------------------------------
--  가. Join은 한 개 이상의 테이블에서, 원하는 데이터를 조회
--  나. 서브쿼리(=부속질의)는, 하나의 SELECT 문장 만으로 원하는
--      데이터를 조회할 수 없을 때 사용하는 방법
--  다. 한 개 이상의 SELECT문장을, 하나로 합쳐서, 하나의 실행가능
--      한 문장으로 만들어, 원하는 데이터를 조회하는 방법
--  라. 종류:
--      (1) 상관 부속질의
--          - 서브쿼리(=부속질의)의 단독 수행이 불가능한 경우
--          - 메인쿼리의 데이터가 있어야 실행가능한 경우로,
--          - 메인쿼리가 먼저 수행되고, 차례대로 서브쿼리가 수행됨
--          - 메인쿼리의 결과가 서브쿼리에 전달되어, 서브쿼리 수행
--      (2) 비상관 부속질의
--          - 서브쿼리(=부속질의)의 단독 수행이 가능한 경우로,
--          - 서브쿼리가 먼저 수행된 다음에, 메인쿼리가 수행됨
--          - 서브쿼리의 결과가 메인쿼리에 전달되어 실행됨
--  마. 사실상, 서브쿼리(=부속질의)는, SELECT 문의 모든 절(clause)
--      에서 뿐만 아니라, 모든 DML문장에서도 사용가능하다!!! (*주의*)
--  사. 반드시 소괄호()를 사용해야 함.
--  아. 구분: 서브쿼리가 실행되어 반환된 행의 개수에 따라,
--      (1) 단일 행 서브쿼리
--          - 서브쿼리 실행 결과가 한 개의 행 반환.
--          - 사용가능 연산자: 비교 연산자 (=, !=, <, >, <=, >=)
--      (2) 복수 행 서브쿼리
--          - 서브쿼리 실행 결과가 복수 개의 행 반환.
--          - 사용가능 연산자: IN, ANY, ALL, EXISTS 등
--  자. 서브쿼리 사용시, **가장 주의해야** 할 점: 사용할 연산자
--      사용된 연산자에 따라, 위 '아'와 같이 행 반환
-- ------------------------------------------------------
-- Basic Syntax)
--
-- SELECT select_list       -- 메인쿼리(바깥쪽 SELECT 문장)
-- FROM 테이블
-- WHERE 컬럼명 연산자 (
--  SELECT select_list FROM 테이블    -- 서브쿼리(안쪽 SELECT 문장)
-- );
-- ------------------------------------------------------
-- * Please refer to the chapter 06, page 2.
-- ------------------------------------------------------
SELECT
    avg(salary)
FROM
    employees e;

--비상관 서브쿼리
SELECT
    avg(salary)
FROM
    employees
WHERE
    salary > (SELECT avg(salary) FROM employees );
---------------------------------------------------------------------

--비상관 부속질의 비상관 서브쿼리.
SELECT              --메인쿼리
    last_name,
    t1.salary
FROM
    employees t1
WHERE
    salary > (
        SELECT          --t1의서브쿼리(t3의 메인쿼리)
            avg(t2.salary) 
        FROM 
            employees t2
        WHERE 
            salary > (
                SELECT          --t1,t2의서브쿼리
                    avg(t3.salary)
                FROM 
                    employees t3
            ) 
    );
---------------------------------------------------------------------

--상관부속질의, 상관 서브 쿼리
SELECT
    last_name,
    salary
FROM
    employees t1
WHERE
    COMMISSION_PCT IS NOT NULL
    AND salary > (
                    SELECT 
                        avg(salary)
                    FROM 
                        employees t2
                    WHERE 
                        t2.employee_id > t1.employee_id
    );
---------------------------------------------------------------------

-- ------------------------------------------------------
-- 사원정보에서, 'Whalen'보다 많은 월급을 받는 사원조회 #1
-- ------------------------------------------------------
-- * 하나의 SELECT문장만으로는 조회불가:
--  가. 먼저, 'Whalen'의 월급이 얼마나인지 알아야 함. (SELECT 1)
--  나. 조회한 'Whalen'의 월급보다 많은 월급을 받는 사원조회가능 (SELECT 2)
-- ------------------------------------------------------

-- SELECT 1: Whalen 의 월급조회(4400)
SELECT
    salary
FROM
    employees
WHERE
    last_name = 'Whalen';

-- SELECT 2: Whalen 보다 월급을 많이 받는 사원 조회
SELECT
    last_name
FROM
    employees
WHERE
    salary > 4400;

-- ------------------------------------------------------
-- 사원정보에서, 'Whalen'보다 많은 월급을 받는 사원조회 #2
-- ------------------------------------------------------
-- 위 #1과 같이, 하나 이상의 SELECT 문장이 있어야만, 원하는 결과
-- 를 조회가능한 경우에, 서브쿼리(=부속질의) 사용가능.
--
-- 즉, 서브쿼리는, 여러 번의 SELECT 문장을 수행해야 얻을 수 있는
-- 결과를, 하나의 중첩된(nested) SELECT 문장으로 만들어, 원하는
-- 결과를 쉽게 조회가능하게 함.
-- ------------------------------------------------------
SELECT
    last_name,
    salary
FROM
    employees
WHERE
    salary > (
        SELECT
            salary
        FROM
            employees
        WHERE
            last_name = 'Whalen'
    );
----------------------------------------------------------

-- ------------------------------------------------------
-- 2. 단일 행 Sub-query
-- ------------------------------------------------------
-- 가. 하나의 행을 반환
-- 나. 반드시 단일 행 서브쿼리를 사용해야만 하는 경우:
--      - 기본키(Primary Key)를 이용하는 경우
--      - 그룹함수(MAX, MIN, SUM 등)를 이용하는 경우
-- ------------------------------------------------------
-- * Please refer to the chapter 06, page 6.
-- ------------------------------------------------------

-- ------------------------------------------------------
-- (1) 평균 월급여보다 많은 월급을 받는 사원조회
-- ------------------------------------------------------
-- 평균 급여를 먼저 구하기 위해, 단일 행 서브쿼리 및 그룹함수 AVG 사용
-- 따라서, 메인쿼리에서 사용가능한 연산자는 하나의 값과 비교하는 비교연산자임!

--비상관 서브쿼리
SELECT
    avg(salary)
FROM
    employees
WHERE
    salary >= (
        SELECT 
            avg(salary) 
        FROM 
            employees 
    );

-- ------------------------------------------------------
-- (2) 100번 부서의 최대 월급여와 동일한 월급을 받는 사원조회
-- ------------------------------------------------------
SELECT
    last_name,
    salary
FROM
    employees
WHERE
    salary = (
        SELECT
            max(salary)
        FROM
            employees
        WHERE
            department_id = 100
    );

-- ------------------------------------------------------
-- (3) 100번 부서의 최대 월급여보다, 많은 월급을 받는 부서조회
-- ------------------------------------------------------
SELECT
    department_id,
    min(salary),
    max(salary),
    avg(salary)
FROM
    employees
GROUP BY
    department_id
HAVING
    avg(salary) >= (
        SELECT
            avg(salary)
        FROM
            employees
        WHERE
            department_id = 100
    );

-- ------------------------------------------------------
-- (4) 사원 Whalen 보다, 채용일자가 느린 사원조회
-- ------------------------------------------------------
SELECT
    last_name,
    hire_date
FROM
    employees
WHERE
    hire_date > (
        SELECT
            hire_date
        FROM
            employees
        WHERE
            last_name = 'Whalen'
    );

-- ------------------------------------------------------
-- 3. 복수 행 Sub-query
-- ------------------------------------------------------
-- 가. 하나 이상의 행을 반환
-- 나. 메인쿼리에서 사용가능한 연산자는 아래와 같음:
--      (1) IN : 메인쿼리와 서브쿼리가 IN 연산자로 비교수행. 
--               서브쿼리 결과값이 복수 개인 경우에 사용.
--      (2) ANY : 서브쿼리에서, > 또는 < 같은 비교 연산자를 사용하고자 
--                할 때 사용. 검색조건이 하나라도 일치하면 참.
--      (3) ALL : 서브쿼리에서 > 또는 < 같은, 비교 연산자를 사용하고자
--                할 때 사용. 검색조건의 모든 값이 일치하면 참.
--      (4) EXISTS : 서브쿼리의 반환값이 존재하면, 메인쿼리를 실행하고,
--                  반환값이 없으면 메인쿼리를 실행하지 않음.
-- ------------------------------------------------------
-- * Please refer to the chapter 06, page 10.
-- ------------------------------------------------------


-- ------------------------------------------------------
-- (1) IN 연산자 사용한 복수행 서브쿼리
-- ------------------------------------------------------
--  가. 서브쿼리 반환값이 복수 개.
--  나. 메인쿼리와 동등비교연산자(=) 방식으로 비교할 때 사용.
-- ------------------------------------------------------

-- 'Whalen' or 'Fay'와 동일한 월급여를 받는 사원조회
SELECT
    last_name,
    salary
FROM
    employees
WHERE
    salary = ANY (
        SELECT 
            salary
        FROM
            employees
        WHERE
            last_name = ANY('Whalen','Fay')
    );

-- 월급여를 13000 보다 많이 받는 부서에 속한 모든 사원 조회
SELECT
    last_name,
    department_id,
    salary
FROM
    employees
WHERE
    department_id = ANY (
        SELECT
            department_id
        FROM
            employees
        WHERE
            salary > 13000
    );

-- ------------------------------------------------------
-- (2) ALL 연산자 사용한 복수행 서브쿼리
-- ------------------------------------------------------
--  가. 서브쿼리 반환값이 복수 개.
--  나. 메인쿼리에서, < or > 같은 비교연산자 사용하고자 할 때 사용.
--  다. 메인쿼리의 비교연산자는 단일 행 연산자이기 때문에,
--      메인쿼리의 복수행 연산자에 ALL 키워드 없이 사용하면 오류발생.
--  라. ALL 연산자:
--      서브쿼리에서 반환된 전체 행들에 대해서, 조건이 모두(all)
--      만족해야 된다는 것을 의미.
--  마. 구분:
--      (1) > ALL (서브쿼리)
--          - 서브쿼리에서 반환된 모든 데이터보다 큰 데이터 조회
--          - 결국, 서브쿼리에서 반환된 모든 데이터 중,
--            *최대값보다 큰* 데이터 조회
--
--      (2) < ALL (서브쿼리)
--          - 서브쿼리에서 반환된 모든 데이터보다 작은 데이터 조회
--          - 결국, 서브쿼리에서 반환된 모든 데이터 중, 
--            *최소값보다 작은* 데이터 조회
-- ------------------------------------------------------
SELECT
    salary
FROM
    employees
WHERE
    job_id = 'IT_PROG'
ORDER BY
    1 ASC;

-- 직책이 IT_PROG인 사원의 월급보다 *작은* 사원 정보 조회
SELECT
    last_name,
    department_id,
    salary
FROM
    employees
WHERE
    salary < ALL(
        SELECT
            salary
        FROM
            employees
        WHERE
            job_id = 'IT_PROG'
    );

-- ------------------------------------------------------
-- (3) ANY 연산자 사용한 복수행 서브쿼리
-- ------------------------------------------------------
--  가. 서브쿼리 반환값이 복수 개.
--  나. 서브쿼리에서, < or > 같은 비교연산자 사용하고자 할 때 사용.
--  다. 메인쿼리의 비교연산자는 단일 행 연산자이기 때문에,
--      메인쿼리의 단일행 연산자에 ANY 키워드 없이 사용하면 오류발생.
--  라. ANY 연산자:
--      서브쿼리에서 반환된 전체 행들에 대해서, 조건이 하나라도(any)
--      만족해야 된다는 것을 의미.
--  마. 구분:
--      (1) > ANY (서브쿼리)
--          - 서브쿼리에서 반환된 모든 데이터보다 큰 데이터 조회
--          - 결국, 서브쿼리에서 반환된 모든 데이터 중,
--            *최소값보다 큰* 데이터 조회
--
--      (2) < ANY (서브쿼리)
--          - 서브쿼리에서 반환된 모든 데이터보다 작은 데이터 조회
--          - 결국, 서브쿼리에서 반환된 모든 데이터 중, 
--            *최대값보다 작은* 데이터 조회
-- ------------------------------------------------------

-- 직책이 IT_PROG인 사원의 *최소 월급여보다 큰* 사원 정보 조회
SELECT
    last_name,
    department_id,
    salary
FROM
    employees
WHERE
    salary = ANY(
        SELECT
            salary
        FROM
            employees
        WHERE
            job_id = 'IT_PROG'
    );

-- ------------------------------------------------------
-- (4) EXISTS 연산자 사용한 복수행 서브쿼리
-- ------------------------------------------------------
--  가. 서브쿼리 반환값이 복수 개.
--  나. 메인쿼리의 값이, 서브쿼리에서 반환된 결과 중에 하나라도
--      존재하는지 여부를 확인할 때 사용하는 복수행 연산자.
--  다. 만일, 서브쿼리의 반환결과가 하나라도 없으면(false),
--      메인쿼리를 수행하지 않음.
--  라. 만일, 서브쿼리의 반환결과가 하나라도 있으면(true),
--      메인쿼리를 수행.
-- ------------------------------------------------------

--commission_pct가 null이 아니라면,(반환결과가 하나라도 있으면) 메인쿼리 수행
SELECT
    last_name,
    department_id,
    salary,
    commission_pct
FROM
    employees
WHERE
    EXISTS (
        SELECT
            1
        FROM
            employees
        WHERE
            commission_pct IS NOT NULL
    );

SELECT
    last_name,
    department_id,
    salary,
    commission_pct
FROM
    employees;

